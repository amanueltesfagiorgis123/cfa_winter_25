# WARNING: DO NOT EDIT THIS FILE
# IF YOU NEED TO ADD CUSTOM FEATURES, YOU CAN USE THE UPDATE FUNCTION IN my_game.py
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
import os
import pygame
from game_engine_options import options

DEBUG_COLLIDERS = options["DEBUG_COLLIDERS"]
VOLUME = options["AUDIO_VOLUME"]

bckgrnd_color = "white"
bckgrnd_image = None

async_tasks = []

#sets up pygame
pygame.init()
pygame.font.init()

#storage for all elements, entities, and text
elements = []
entities = []
solid_entities = []
texts = []
curr_input = None

# stores the desired screen size (can be resized to scale this but resolution will remain the same)
screen_width = 1280
screen_height = 720

# these are the acceptable inputs for the player
key_dict = {pygame.K_w : "w", pygame.K_a: "a", pygame.K_s: "s", pygame.K_d: "d",
                pygame.K_RIGHT: "right", pygame.K_LEFT: "left", pygame.K_UP: "up", pygame.K_DOWN: "down",
                pygame.K_SPACE: "space"}

imgs = {}
audio = {}
game_scaling = 1
game_display_offset = (0, 0)

def load_all_images(curr_path):
    img_files = os.listdir(curr_path)
    for file in img_files:
        if os.path.isdir(curr_path + "/" + file):
            load_all_images(curr_path + "/" + file)
        else:
            imgs[file] = pygame.image.load(curr_path + "/" + file)


def load_all_audio(curr_path):
    audio_files = os.listdir(curr_path)
    print(audio_files)
    for file in audio_files:
        if os.path.isdir(curr_path + "/" + file):
            load_all_audio(curr_path + "/" + file)
        else:
            audio[file] = pygame.mixer.Sound(curr_path + "/" + file)
            audio[file].set_volume(VOLUME/100)

load_all_images("./images")
print("Loaded images:", list(imgs.keys()))

load_all_audio("./audio")
print("Loaded audio:", list(audio.keys()))


def start(update):
    # pygame setup
    clock = pygame.time.Clock()
    running = True
    
    keys_held = []

    screen = pygame.display.set_mode((screen_width, screen_height), pygame.RESIZABLE)
    print("screen size", (screen_width, screen_height))
    print("------------------------------------------------------------")

    # update loop
    while running:
        game_display = pygame.Surface((screen_width, screen_height))
        tick_time = clock.get_time()/1000
        # poll for events
        # pygame.QUIT event means the user clicked X to close your window
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            if event.type == pygame.KEYDOWN:
                if curr_input != None:
                    curr_input.receive_input(event)
                elif event.key in key_dict:
                    keys_held.append(key_dict[event.key])
            if event.type == pygame.KEYUP:
                if event.key in key_dict and key_dict[event.key] in keys_held:
                    keys_held.remove(key_dict[event.key])
            if event.type == pygame.MOUSEBUTTONDOWN:
                mouse_pos = pygame.mouse.get_pos()
                scaled_mouse_pos = ((mouse_pos[0] - game_display_offset[0]) / game_scaling, (mouse_pos[1] - game_display_offset[1]) / game_scaling)
                for element in entities + texts:
                    if hasattr(element, "on_click") and element.rect.collidepoint(scaled_mouse_pos):
                        element.on_click(element)

        game_display.fill(bckgrnd_color)
        if bckgrnd_image != None:
            game_display.blit(bckgrnd_image, [0, 0])

        update()

        #run any async tasks occuring
        for task in async_tasks:
            task['curr_time'] += tick_time
            if task['curr_time'] >= task['stop_time']:
                #run the function

                iteration = task['iterations'].pop(0)
                task['func'](iteration)
                task['curr_time'] -= task['stop_time']
                if len(task['iterations']) <= 0:
                    async_tasks.remove(task)

        # reset necessary values for new update
        for entity in entities:
            if hasattr(entity, "rect_color"):
                entity.rect_color = "Red"

        # update movement input for wasd and arrows
        for entity in entities:
            if len(entity.move) > 0 or hasattr(entity, "jump"):
                entity.update_inputs(keys_held)

        # update movement
        if (tick_time > 0):
            for entity in entities:
                if hasattr(entity, "velocity"):
                    entity.update_movement(tick_time)

        # update angular movement
        if (tick_time > 0):
            for entity in entities:
                if hasattr(entity, "angular_velocity"):
                    entity.update_rotational_movement(tick_time)

        # check collision
        for entity in entities:
            if hasattr(entity, "rect"):
                entity.update_collision()
        
        # handle collision for solid entities
        for entity in solid_entities:
            if hasattr(entity, "velocity"):
                for target in entity.solid_colliders:
                    entity.collision_handeler(target)


        # draw all sprites to screen
        for entity in entities:
            entity.render(game_display)
            if hasattr(entity, "rect") and DEBUG_COLLIDERS:
                pygame.draw.rect(game_display, entity.rect_color, entity.rect, 2)
            if hasattr(entity, "feet_point") and DEBUG_COLLIDERS:
                pygame.draw.circle(game_display, entity.rect_color, entity.feet_point, 4)
        # pygame.sprite.Group().draw(screen)

        # draw all text to screen
        for text in texts:
            game_display.blit(text.rendered_text, text.get_pos())
            if hasattr(text, "rect") and DEBUG_COLLIDERS:
                pygame.draw.rect(game_display, text.rect_color, text.rect, 2)
            

        screen.fill("black")   
        game_scaling = min(screen.get_width()/screen_width, screen.get_height()/screen_height)
        scaled_game_display = pygame.transform.smoothscale_by(game_display, game_scaling)
        game_display_offset = (-(scaled_game_display.get_width() - screen.get_width())/2, -(scaled_game_display.get_height() - screen.get_height())/2)
        screen.blit(scaled_game_display, game_display_offset)
        # flip() the display to put your work on screen
        pygame.display.flip()

        clock.tick(60)  # limits FPS to 60

    pygame.quit()